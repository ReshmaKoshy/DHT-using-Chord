Implementation: When our Chord network starts up, we first create node 0 and give it all our initial data (key-value pairs). Then, as other nodes join the network one by one, we redistribute the keys. Each new node takes the keys it should be responsible for based on its position in the ring. Each node maintains its immediate neighbors (successor and predecessor) and it keeps a finger table of size m.  We run stabilization and fix_finger to update the successor, predecessor and finger tables. Then, requests are generated randomly at each node, which can fall at any point on the ring. These are routed in a maximum of log2(n) hops to the appropriate node with the key.
Usage: DHT-using-Chord ./DHT-using-Chord <number of nodes> <number of requests>

We have simulated failure where program takes the number of nodes that need to fail as the third argument. After nodes join the network and while requests are being sent out, we simulate the permanent failure of k random nodes. The periodic_stabilize function, which runs every second, then resets the appropriate successor, predecessor values, and finger table entries. Hence all requests to the failed node are now routed to the predecessor of the failed node which is responsible for answering the queries.
Usage: DHT-using-Chord ./DHT-using-Chord <number of nodes> <number of requests> <number of failures in network>
